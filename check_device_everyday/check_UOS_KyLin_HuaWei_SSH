#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#!version:1.1
"""
@è®¾å¤‡çŠ¶æ€å·¡æ£€è„šæœ¬
@åŠŸèƒ½:æ£€æŸ¥éº’éºŸç³»ç»Ÿã€ç»Ÿä¿¡ç³»ç»Ÿã€æœåŠ¡å™¨ã€ç½‘ç»œè®¾å¤‡å’Œæ‰“å°æœºçš„åŸºæœ¬è¿è¡ŒçŠ¶æ€
@ä½œè€…:å·¡æ£€ç³»ç»Ÿ
@æ—¥æœŸ:2026-02-06
@æ”¹è¿›:æ·»åŠ è®¾å¤‡æ’åºã€å¯é…ç½®ä¿å­˜ä½ç½®
"""

import subprocess
import socket
import time
import os
import sys
import platform
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, List, Tuple
import logging
from datetime import datetime

# é…ç½®æ—¥å¿— - ç§»é™¤æ§åˆ¶å°æ—¥å¿—ä¸­çš„Unicodeå­—ç¬¦
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('device_check.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class DeviceChecker:
    def __init__(self, output_dir: str = "."):
        """
        åˆå§‹åŒ–è®¾å¤‡æ£€æŸ¥å™¨
        
        Args:
            output_dir: æŠ¥å‘Šä¿å­˜ç›®å½•
        """
        self.output_dir = output_dir
        
        # åˆ›å»ºä¿å­˜ç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # è·å–å½“å‰æ“ä½œç³»ç»Ÿ
        self.os_type = platform.system().lower()
        logger.info(f"å½“å‰æ“ä½œç³»ç»Ÿ: {self.os_type}")
        
        # è®¾å¤‡åˆ—è¡¨ - è¯·æ ¹æ®å®é™…æƒ…å†µä¿®æ”¹IPåœ°å€å’Œå‡­æ®
        self.devices = {
            # éº’éºŸ/ç»Ÿä¿¡å°å¼æœº (4å°)
            'desktop1': {'ip': '172.16.11.1', 'type': 'kylin', 'port': 22, 'username': 'admin', 'order': 1},
            'desktop2': {'ip': '172.16.11.2', 'type': 'uos', 'port': 22, 'username': 'admin', 'order': 2},
            'desktop3': {'ip': '172.16.11.3', 'type': 'uos', 'port': 22, 'username': 'admin', 'order': 3},
            'desktop4': {'ip': '172.16.11.4', 'type': 'kylin', 'port': 22, 'username': 'admin', 'order': 4},
            
            # ç¬”è®°æœ¬ç”µè„‘ (2å°)
            'laptop1': {'ip': '172.16.11.5', 'type': 'uos', 'port': 22, 'username': 'admin', 'order': 5},
            'laptop2': {'ip': '172.16.11.6', 'type': 'uos', 'port': 22, 'username': 'admin', 'order': 6},
            
            # æœåŠ¡å™¨ (4å°)
            'server1': {'ip': '172.16.13.1', 'type': 'server', 'port': 22, 'username': 'root', 'order': 7},
            'server2': {'ip': '172.16.13.2', 'type': 'server', 'port': 22, 'username': 'root', 'order': 8},
            'server3': {'ip': '172.16.13.3', 'type': 'server', 'port': 22, 'username': 'root', 'order': 9},
            'server4': {'ip': '172.16.13.4', 'type': 'server', 'port': 22, 'username': 'root', 'order': 10},
            
            # å…³é”®ç½‘ç»œè®¾å¤‡
            'huawei_switch': {'ip': '172.16.11.254', 'type': 'huawei_switch', 'port': 22, 'order': 11},
            'huawei_firewall': {'ip': '172.16.1.14', 'type': 'huawei_firewall', 'port': 22, 'order': 12},
            
            # æ‰“å°æœº
            'printer': {'ip': '172.16.11.7', 'type': 'printer', 'port': 9100, 'order': 13}
        }
        
        # è®¾å¤‡ç±»å‹æ’åºæ˜ å°„
        self.type_order = {
            'kylin': 1,       # éº’éºŸç³»ç»Ÿ
            'uos': 2,         # ç»Ÿä¿¡ç³»ç»Ÿ
            'server': 3,      # æœåŠ¡å™¨
            'huawei_switch': 4,  # åä¸ºäº¤æ¢æœº
            'huawei_firewall': 5, # åä¸ºé˜²ç«å¢™
            'printer': 6      # æ‰“å°æœº
        }
        
        # æ ¹æ®æ“ä½œç³»ç»Ÿè®¾ç½®pingå‚æ•°
        self.ping_count = 2  # pingæ¬¡æ•°
        if self.os_type == 'windows':
            self.ping_timeout = 2000  # æ¯«ç§’
        else:
            self.ping_timeout = 2    # ç§’
        
        # Windowsç³»ç»Ÿä¸‹ï¼Œè®¾ç½®æ§åˆ¶å°ç¼–ç ä¸ºUTF-8
        if self.os_type == 'windows':
            try:
                import ctypes
                # å°è¯•è®¾ç½®æ§åˆ¶å°ç¼–ç ä¸ºUTF-8
                if hasattr(sys.stdout, 'reconfigure'):
                    sys.stdout.reconfigure(encoding='utf-8')
            except:
                pass
    
    def check_port(self, host: str, port: int, timeout: int = 3) -> bool:
        """æ£€æŸ¥ç«¯å£æ˜¯å¦å¼€æ”¾"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except Exception:
            return False
    
    def ping_host(self, host: str) -> Tuple[bool, str]:
        """Pingä¸»æœºæ£€æŸ¥è¿é€šæ€§"""
        try:
            if self.os_type == 'windows':
                # Windowsç³»ç»Ÿpingå‘½ä»¤
                command = ['ping', '-n', str(self.ping_count), '-w', str(self.ping_timeout), host]
            else:
                # Linux/Unixç³»ç»Ÿpingå‘½ä»¤
                command = ['ping', '-c', str(self.ping_count), '-W', str(self.ping_timeout), host]
            
            # æ‰§è¡Œpingå‘½ä»¤
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                encoding='gbk' if self.os_type == 'windows' else 'utf-8'
            )
            
            stdout, stderr = process.communicate(timeout=5)
            
            # æ£€æŸ¥è¾“å‡ºä¸­æ˜¯å¦åŒ…å«æˆåŠŸå…³é”®è¯
            success_keywords = ['ttl=', 'æ¥è‡ª', 'bytes from', 'reply from', 'ttl =']
            stdout_lower = stdout.lower()
            
            for keyword in success_keywords:
                if keyword in stdout_lower:
                    return True, "PingæˆåŠŸ"
            
            # æ£€æŸ¥è¿”å›ç 
            if process.returncode == 0:
                return True, "PingæˆåŠŸ"
            
            return False, f"Pingå¤±è´¥ï¼Œè¿”å›ç : {process.returncode}"
                
        except subprocess.TimeoutExpired:
            return False, "å‘½ä»¤æ‰§è¡Œè¶…æ—¶"
        except Exception as e:
            return False, f"Pingé”™è¯¯: {str(e)}"
    
    def check_host_by_multiple_methods(self, host: str, port: int = None) -> Tuple[bool, str, str]:
        """
        ä½¿ç”¨å¤šç§æ–¹æ³•æ£€æŸ¥ä¸»æœºçŠ¶æ€
        è¿”å›: (æ˜¯å¦å¯è¾¾, ä½¿ç”¨çš„æ–¹æ³•, è¯¦ç»†ä¿¡æ¯)
        """
        # æ–¹æ³•1: Pingæ£€æµ‹
        ping_success, ping_msg = self.ping_host(host)
        if ping_success:
            return True, "ping", ping_msg
        
        # æ–¹æ³•2: ç«¯å£æ£€æµ‹ï¼ˆå¦‚æœæŒ‡å®šäº†ç«¯å£ï¼‰
        if port and self.check_port(host, port, timeout=2):
            return True, f"ç«¯å£{port}", f"ç«¯å£{port}å¼€æ”¾"
        
        # æ–¹æ³•3: å¸¸è§ç«¯å£æ£€æµ‹ï¼ˆå¦‚æœæ²¡æœ‰æŒ‡å®šç«¯å£ï¼‰
        if not port:
            common_ports = [22, 23, 80, 443, 3389, 5900, 8080]
            for common_port in common_ports:
                if self.check_port(host, common_port, timeout=1):
                    return True, f"ç«¯å£{common_port}", f"å¸¸è§ç«¯å£{common_port}å¼€æ”¾"
        
        # æ–¹æ³•4: DNSè§£æ
        try:
            socket.gethostbyname(host)
            return False, "dns", "DNSè§£ææˆåŠŸä½†æ— æ³•è¿æ¥"
        except socket.gaierror:
            pass
        
        return False, "all", "æ‰€æœ‰æ£€æµ‹æ–¹æ³•éƒ½å¤±è´¥"
    
    def check_linux_device(self, device_name: str, device_info: Dict) -> Dict:
        """æ£€æŸ¥Linuxè®¾å¤‡(éº’éºŸ/UOS/æœåŠ¡å™¨)"""
        result = {
            'name': device_name,
            'ip': device_info['ip'],
            'type': device_info['type'],
            'status': 'unknown',
            'response_time': None,
            'details': '',
            'order': device_info.get('order', 999),
            'check_method': 'unknown'
        }
        
        start_time = time.time()
        ip_address = device_info['ip']
        port = device_info.get('port', 22)
        device_type = device_info['type']
        
        # ä½¿ç”¨å¤šç§æ–¹æ³•æ£€æŸ¥è®¾å¤‡çŠ¶æ€
        reachable, method, detail = self.check_host_by_multiple_methods(ip_address, port)
        
        if reachable:
            ssh_available = False
            if method == f"ç«¯å£{port}":
                ssh_available = True
            else:
                ssh_available = self.check_port(ip_address, port, timeout=3)

            
            if ssh_available:
                result['status'] = 'online'
                result['details'] = f'è®¾å¤‡è¿è¡Œæ­£å¸¸ (æ£€æµ‹æ–¹å¼: {method})'
            else:
                #ç»ˆç«¯è®¾å¤‡sshä¸å¯ç”¨è§†ä¸ºæ­£å¸¸ï¼ŒæœåŠ¡å™¨sshä¸å¯ç”¨è§†ä¸ºå¼‚å¸¸
                if device_type in ['kylin', 'uos']:
                            result['status'] = 'online'
                            result['details'] = f'è®¾å¤‡åœ¨çº¿,SSHæœåŠ¡æœªå¼€å¯(ç»ˆç«¯è®¾å¤‡å¯æ¥å—)'
                else:
                            result['status'] = 'warning'
                            result['details'] = f'è®¾å¤‡å¯è¾¾ä½†SSHç«¯å£ä¸å¯ç”¨(æ£€æµ‹æ–¹å¼: {method})'
        
        else:
            result['status'] = 'offline'
            result['details'] = f'è®¾å¤‡ä¸å¯è¾¾: {detail}'

        result['response_time'] = time.time() - start_time
        result['check_method'] = method
        return result


    
    def check_network_device(self, device_name: str, device_info: Dict) -> Dict:
        """æ£€æŸ¥åä¸ºç½‘ç»œè®¾å¤‡ï¼ˆäº¤æ¢æœºã€é˜²ç«å¢™ï¼‰"""
        result = {
            'name': device_name,
            'ip': device_info['ip'],
            'type': device_info['type'],
            'status': 'unknown',
            'response_time': None,
            'details': '',
            'order': device_info.get('order', 999),
            'check_method': 'unknown'
        }
        
        start_time = time.time()
        ip_address = device_info['ip']
        port = device_info.get('port', 22)
        
        # ä½¿ç”¨å¤šç§æ–¹æ³•æ£€æŸ¥è®¾å¤‡çŠ¶æ€
        reachable, method, detail = self.check_host_by_multiple_methods(ip_address, port)
        
        if reachable:
            if self.check_port(ip_address, port, timeout=3):
                result['status'] = 'online'
                result['details'] = f'ç½‘ç»œè®¾å¤‡è¿è¡Œæ­£å¸¸ (æ£€æµ‹æ–¹å¼: {method})'
            else:
                result['status'] = 'warning'
                result['details'] = f'è®¾å¤‡å¯è¾¾ä½†ç®¡ç†ç«¯å£ä¸å¯ç”¨ (æ£€æµ‹æ–¹å¼: {method})'
        else:
            result['status'] = 'offline'
            result['details'] = f'è®¾å¤‡ä¸å¯è¾¾: {detail}'
        
        result['response_time'] = time.time() - start_time
        result['check_method'] = method
        
        return result
    
    def check_printer(self, device_name: str, device_info: Dict) -> Dict:
        """æ£€æŸ¥æ‰“å°æœºçŠ¶æ€"""
        result = {
            'name': device_name,
            'ip': device_info['ip'],
            'type': device_info['type'],
            'status': 'unknown',
            'response_time': None,
            'details': '',
            'order': device_info.get('order', 999),
            'check_method': 'unknown'
        }
        
        start_time = time.time()
        ip_address = device_info['ip']
        
        # ä½¿ç”¨å¤šç§æ–¹æ³•æ£€æŸ¥è®¾å¤‡çŠ¶æ€ï¼ˆä¸æŒ‡å®šç«¯å£ï¼‰
        reachable, method, detail = self.check_host_by_multiple_methods(ip_address)
        
        if reachable:
            # æ£€æŸ¥æ‰“å°æœºå¸¸ç”¨ç«¯å£
            printer_ports = [9100, 515, 631, 80]
            port_available = False
            
            for port in printer_ports:
                if self.check_port(ip_address, port, timeout=2):
                    port_available = True
                    break
            
            if port_available:
                result['status'] = 'online'
                result['details'] = f'æ‰“å°æœºè¿è¡Œæ­£å¸¸ (æ£€æµ‹æ–¹å¼: {method})'
            else:
                result['status'] = 'warning'
                result['details'] = f'æ‰“å°æœºåœ¨çº¿ä½†æ‰“å°æœåŠ¡ç«¯å£ä¸å¯ç”¨ (æ£€æµ‹æ–¹å¼: {method})'
        else:
            result['status'] = 'offline'
            result['details'] = f'æ‰“å°æœºä¸å¯è¾¾: {detail}'
        
        result['response_time'] = time.time() - start_time
        result['check_method'] = method
        
        return result
    
    def get_sorted_devices(self) -> List[Tuple[str, Dict]]:
        """è·å–æ’åºåçš„è®¾å¤‡åˆ—è¡¨"""
        devices_list = []
        for name, info in self.devices.items():
            device_info = info.copy()
            
            # æå–è®¾å¤‡åºå·
            import re
            numbers = re.findall(r'\d+', name)
            device_order = int(numbers[0]) if numbers else float('inf')
            
            # ç±»å‹æ’åºå€¼
            type_order = self.type_order.get(info['type'], 99)
            
            # åˆ›å»ºæ’åºé”®
            sort_key = (type_order, device_order, name)
            devices_list.append((sort_key, name, device_info))
        
        # æŒ‰æ’åºé”®æ’åº
        devices_list.sort(key=lambda x: x[0])
        
        return [(name, info) for _, name, info in devices_list]
    
    def check_single_device(self, device_name: str, device_info: Dict) -> Tuple[str, Dict]:
        """æ£€æŸ¥å•ä¸ªè®¾å¤‡"""
        device_type = device_info['type']
        
        try:
            if device_type in ['kylin', 'uos', 'server']:
                result = self.check_linux_device(device_name, device_info)
            elif device_type in ['huawei_switch', 'huawei_firewall']:
                result = self.check_network_device(device_name, device_info)
            elif device_type == 'printer':
                result = self.check_printer(device_name, device_info)
            else:
                result = {
                    'name': device_name,
                    'ip': device_info['ip'],
                    'type': device_type,
                    'status': 'error',
                    'details': 'æœªçŸ¥è®¾å¤‡ç±»å‹',
                    'order': device_info.get('order', 999),
                    'check_method': 'unknown'
                }
        except Exception as e:
            result = {
                'name': device_name,
                'ip': device_info['ip'],
                'type': device_type,
                'status': 'error',
                'details': f'æ£€æŸ¥è¿‡ç¨‹ä¸­å‡ºé”™: {str(e)}',
                'order': device_info.get('order', 999),
                'check_method': 'unknown'
            }
        
        return device_name, result
    
    def check_all_devices(self) -> Dict[str, Dict]:
        """å¹¶å‘æ£€æŸ¥æ‰€æœ‰è®¾å¤‡"""
        logger.info("å¼€å§‹è®¾å¤‡å·¡æ£€...")
        
        # è·å–æ’åºåçš„è®¾å¤‡åˆ—è¡¨
        sorted_devices = self.get_sorted_devices()
        logger.info(f"æ€»è®¡è®¾å¤‡æ•°: {len(sorted_devices)}")
        logger.info(f"æ“ä½œç³»ç»Ÿ: {self.os_type}")
        
        results = {}
        
        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘æ£€æŸ¥
        with ThreadPoolExecutor(max_workers=5) as executor:
            future_to_device = {
                executor.submit(self.check_single_device, device_name, device_info): device_name 
                for device_name, device_info in sorted_devices
            }
            
            for future in as_completed(future_to_device):
                device_name = future_to_device[future]
                try:
                    name, result = future.result()
                    results[name] = result
                    
                    # ä½¿ç”¨ç®€å•çš„æ–‡æœ¬ç¬¦å·æ›¿ä»£Unicodeå­—ç¬¦ï¼Œé¿å…ç¼–ç é—®é¢˜
                    status_symbol = {
                        'online': '[OK]',
                        'offline': '[X]',
                        'warning': '[!]',
                        'error': '[?]'
                    }.get(result['status'], '[?]')
                    
                    logger.info(f"{status_symbol} è®¾å¤‡ {name} ({result['ip']}) - çŠ¶æ€: {result['status']}")
                except Exception as e:
                    logger.error(f"æ£€æŸ¥è®¾å¤‡ {device_name} æ—¶å‡ºé”™: {e}")
                    results[device_name] = {
                        'name': device_name,
                        'status': 'error',
                        'details': f'æ£€æŸ¥å¤±è´¥: {str(e)}',
                        'order': 999,
                        'check_method': 'unknown'
                    }
        
        return results
    
    def generate_report(self, results: Dict[str, Dict]) -> str:
        """ç”Ÿæˆå·¡æ£€æŠ¥å‘Š"""
        report_lines = []
        report_lines.append("=" * 70)
        report_lines.append(f"è®¾å¤‡å·¡æ£€æŠ¥å‘Š - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report_lines.append(f"æ“ä½œç³»ç»Ÿ: {self.os_type.upper()}")
        report_lines.append("=" * 70)
        
        # ç»Ÿè®¡ä¿¡æ¯ - ä½¿ç”¨å›ºå®šå®½åº¦æ ¼å¼åŒ–ç¡®ä¿å¯¹é½
        total = len(results)
        online_count = sum(1 for r in results.values() if r.get('status') == 'online')
        offline_count = sum(1 for r in results.values() if r.get('status') == 'offline')
        warning_count = sum(1 for r in results.values() if r.get('status') == 'warning')
        error_count = sum(1 for r in results.values() if r.get('status') == 'error')
        
        # æ ¹æ®æ“ä½œç³»ç»Ÿé€‰æ‹©ç¬¦å·
        if self.os_type == 'windows':
            # Windowsä½¿ç”¨ç®€å•çš„ASCIIç¬¦å·
            symbols = {
                'total': 'ç»Ÿè®¡ä¿¡æ¯',
                'online': 'åœ¨çº¿è®¾å¤‡',
                'offline': 'ç¦»çº¿è®¾å¤‡', 
                'warning': 'è­¦å‘Šè®¾å¤‡',
                'error': 'é”™è¯¯è®¾å¤‡',
                'icon_online': '[OK]',
                'icon_offline': '[X]',
                'icon_warning': '[!]',
                'icon_error': '[?]',
                'chart': 'çŠ¶æ€åˆ†å¸ƒ',
                'alert': 'å¼‚å¸¸è®¾å¤‡',
                'dir': 'æŠ¥å‘Šä½ç½®',
                'time': 'å®Œæˆæ—¶é—´',
                'file': 'æ–‡ä»¶'
            }
        else:
            # éWindowsç³»ç»Ÿä½¿ç”¨Unicodeç¬¦å·
            symbols = {
                'total': 'ğŸ“Š ç»Ÿè®¡ä¿¡æ¯',
                'online': 'åœ¨çº¿è®¾å¤‡',
                'offline': 'ç¦»çº¿è®¾å¤‡',
                'warning': 'è­¦å‘Šè®¾å¤‡',
                'error': 'é”™è¯¯è®¾å¤‡',
                'icon_online': 'âœ…',
                'icon_offline': 'âŒ',
                'icon_warning': 'âš ï¸',
                'icon_error': 'â“',
                'chart': 'ğŸ“ˆ çŠ¶æ€åˆ†å¸ƒ',
                'alert': 'ğŸš¨ å¼‚å¸¸è®¾å¤‡',
                'dir': 'ğŸ“ æŠ¥å‘Šä½ç½®',
                'time': 'â° å®Œæˆæ—¶é—´',
                'file': 'ğŸ“„ æ–‡ä»¶'
            }
        
        report_lines.append(f"\n{symbols['total']}:")
        report_lines.append(f"  æ€»è®¡è®¾å¤‡: {total:>3}")
        report_lines.append(f"  åœ¨çº¿è®¾å¤‡: {online_count:>3} {symbols['icon_online']}")
        report_lines.append(f"  ç¦»çº¿è®¾å¤‡: {offline_count:>3} {symbols['icon_offline']}")
        report_lines.append(f"  è­¦å‘Šè®¾å¤‡: {warning_count:>3} {symbols['icon_warning']}")
        report_lines.append(f"  é”™è¯¯è®¾å¤‡: {error_count:>3} {symbols['icon_error']}")
        
        # è®¾å¤‡çŠ¶æ€åˆ†å¸ƒå¯è§†åŒ–ï¼ˆå¯é€‰ï¼‰
        if total > 0:
            report_lines.append(f"\n{symbols['chart']}:")
            bar_length = 20
            online_bar = 'â–ˆ' * int(online_count / total * bar_length) if total > 0 else ''
            offline_bar = 'â–ˆ' * int(offline_count / total * bar_length) if total > 0 else ''
            warning_bar = 'â–ˆ' * int(warning_count / total * bar_length) if total > 0 else ''
            error_bar = 'â–ˆ' * int(error_count / total * bar_length) if total > 0 else ''
            
            report_lines.append(f"  åœ¨çº¿: [{online_bar:<{bar_length}}] {online_count/total*100:.1f}%")
            report_lines.append(f"  ç¦»çº¿: [{offline_bar:<{bar_length}}] {offline_count/total*100:.1f}%")
            report_lines.append(f"  è­¦å‘Š: [{warning_bar:<{bar_length}}] {warning_count/total*100:.1f}%")
            report_lines.append(f"  é”™è¯¯: [{error_bar:<{bar_length}}] {error_count/total*100:.1f}%")
        
        # æŒ‰è®¾å¤‡ç±»å‹åˆ†ç»„æ˜¾ç¤ºï¼Œå¹¶æŒ‰æ’åºé¡ºåº
        device_types = {}
        for device_name, result in results.items():
            dev_type = result.get('type', 'unknown')
            if dev_type not in device_types:
                device_types[dev_type] = []
            device_types[dev_type].append((device_name, result))
        
        # æŒ‰ç…§ç±»å‹æ’åºé¡ºåºæ˜¾ç¤º
        for dev_type in sorted(self.type_order.keys(), key=lambda x: self.type_order.get(x, 99)):
            if dev_type not in device_types:
                continue
                
            # è·å–ç±»å‹æ˜¾ç¤ºåç§°
            type_display_names = {
                'kylin': 'éº’éºŸç³»ç»Ÿ',
                'uos': 'ç»Ÿä¿¡ç³»ç»Ÿ(UOS)',
                'server': 'æœåŠ¡å™¨',
                'huawei_switch': 'åä¸ºäº¤æ¢æœº',
                'huawei_firewall': 'åä¸ºé˜²ç«å¢™',
                'printer': 'æ‰“å°æœº'
            }
            display_name = type_display_names.get(dev_type, dev_type)
            
            # å¯¹è¯¥ç±»å‹ä¸‹çš„è®¾å¤‡æŒ‰orderå­—æ®µæ’åº
            devices = device_types[dev_type]
            devices.sort(key=lambda x: x[1].get('order', 999))
            
            # ç»Ÿè®¡è¯¥ç±»å‹è®¾å¤‡çš„çŠ¶æ€
            type_total = len(devices)
            type_online = sum(1 for _, r in devices if r.get('status') == 'online')
            type_offline = sum(1 for _, r in devices if r.get('status') == 'offline')
            type_warning = sum(1 for _, r in devices if r.get('status') == 'warning')
            type_error = sum(1 for _, r in devices if r.get('status') == 'error')
            
            report_lines.append(f"\n{display_name} è®¾å¤‡ ({type_total}å°):")
            report_lines.append(f"  çŠ¶æ€: åœ¨çº¿:{type_online:>2} ç¦»çº¿:{type_offline:>2} è­¦å‘Š:{type_warning:>2} é”™è¯¯:{type_error:>2}")
            report_lines.append("-" * 60)
            
            for device_name, result in devices:
                # æ ¹æ®æ“ä½œç³»ç»Ÿé€‰æ‹©çŠ¶æ€å›¾æ ‡
                if self.os_type == 'windows':
                    status_icon = {
                        'online': '[OK]',
                        'offline': '[X]',
                        'warning': '[!]',
                        'error': '[?]'
                    }.get(result['status'], '[?]')
                else:
                    status_icon = {
                        'online': 'âœ…',
                        'offline': 'âŒ',
                        'warning': 'âš ï¸',
                        'error': 'â“'
                    }.get(result['status'], 'â”')
                
                # æ ¼å¼åŒ–å“åº”æ—¶é—´
                response_time = result.get('response_time')
                if response_time:
                    response_str = f"{response_time:.2f}s"
                else:
                    response_str = "N/A"
                
                # ä½¿ç”¨å›ºå®šå®½åº¦ç¡®ä¿å„åˆ—å¯¹é½
                report_lines.append(
                    f"{status_icon} {device_name:15} | "
                    f"IP: {result.get('ip', 'N/A'):15} | "
                    f"çŠ¶æ€: {result['status']:8} | "
                    f"å“åº”: {response_str:>7} | "
                    f"{result.get('details', '')}"
                )
        
        # å¼‚å¸¸è®¾å¤‡æ±‡æ€»ï¼ˆæŒ‰é¡ºåºï¼‰
        abnormal_devices = [
            (name, result) for name, result in results.items() 
            if result.get('status') in ['offline', 'warning', 'error']
        ]
        
        # å¯¹å¼‚å¸¸è®¾å¤‡æŒ‰orderæ’åº
        abnormal_devices.sort(key=lambda x: x[1].get('order', 999))
        
        if abnormal_devices:
            report_lines.append(f"\n{symbols['alert']}æ±‡æ€» ({len(abnormal_devices)}å°):")
            report_lines.append("-" * 60)
            for device_name, result in abnormal_devices:
                if self.os_type == 'windows':
                    status_icon = {
                        'offline': '[X]',
                        'warning': '[!]',
                        'error': '[?]'
                    }.get(result['status'], '[?]')
                else:
                    status_icon = {
                        'offline': 'âŒ',
                        'warning': 'âš ï¸',
                        'error': 'â“'
                    }.get(result['status'], 'â”')
                
                report_lines.append(f"{status_icon} {device_name:15} | {result.get('details', 'æœªçŸ¥å¼‚å¸¸')}")
        
        report_lines.append(f"\n{symbols['dir']}: {os.path.abspath(self.output_dir)}")
        report_lines.append(f"{symbols['time']}: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report_lines.append("=" * 70)
        
        return "\n".join(report_lines)

def main():
    """ä¸»å‡½æ•°"""
    print("=" * 60)
    print("è®¾å¤‡çŠ¶æ€å·¡æ£€ç³»ç»Ÿ v1.2 (Windowså…¼å®¹ç‰ˆ)")
    print(f"è¿è¡Œç¯å¢ƒ: {platform.system()} {platform.release()}")
    print("=" * 60)
    
    # è®¾ç½®ä¿å­˜ç›®å½•
    output_dir = "./reports"
    
    # åˆå§‹åŒ–æ£€æŸ¥å™¨
    checker = DeviceChecker(output_dir=output_dir)
    
    print(f"æŠ¥å‘Šä¿å­˜ç›®å½•: {os.path.abspath(output_dir)}")
    print("\næ­£åœ¨æ£€æŸ¥è®¾å¤‡çŠ¶æ€...")
    print("æç¤ºï¼šå¦‚æœè®¾å¤‡æ— æ³•pingé€šä½†å®é™…å¯ç”¨ï¼Œè„šæœ¬ä¼šå°è¯•ç«¯å£æ£€æµ‹ç­‰å…¶ä»–æ–¹æ³•\n")
    
    # æ‰§è¡Œæ£€æŸ¥
    start_time = time.time()
    results = checker.check_all_devices()
    total_time = time.time() - start_time
    
    # ç”Ÿæˆå¹¶æ˜¾ç¤ºæŠ¥å‘Š
    report = checker.generate_report(results)
    
    # å®‰å…¨æ‰“å°æŠ¥å‘Šï¼ˆé¿å…ç¼–ç é”™è¯¯ï¼‰
    try:
        print("\n" + report)
    except UnicodeEncodeError:
        # å¦‚æœæ‰“å°å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç®€å•æ–‡æœ¬
        print("\næ³¨æ„:ç”±äºç¼–ç é—®é¢˜ï¼Œéƒ¨åˆ†ç‰¹æ®Šå­—ç¬¦å¯èƒ½æ— æ³•æ˜¾ç¤º")
        # æ›¿æ¢Unicodeå­—ç¬¦
        safe_report = report
        replacements = [
            ('âœ…', '[OK]'), ('âŒ', '[X]'), ('âš ï¸', '[!]'), ('â“', '[?]'),
            ('ğŸ“Š', 'ç»Ÿè®¡'), ('ğŸš¨', 'è­¦æŠ¥'), ('ğŸ“', 'ç›®å½•'), ('â°', 'æ—¶é—´'),
            ('ğŸ“„', 'æ–‡ä»¶'), ('â–ˆ', '#')
        ]
        for uni_char, ascii_char in replacements:
            safe_report = safe_report.replace(uni_char, ascii_char)
        print("\n" + safe_report)
    
    print(f"\næ€»æ£€æŸ¥æ—¶é—´: {total_time:.2f}ç§’")
    
    # ä¿å­˜æŠ¥å‘Šåˆ°æ–‡ä»¶ï¼ˆä½¿ç”¨UTF-8ç¼–ç ï¼‰
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(output_dir, f"device_inspection_report_{timestamp}.txt")
    
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(report)
        print(f"\næŠ¥å‘Šå·²ä¿å­˜åˆ°: {filename}")
    except Exception as e:
        # å¦‚æœä¿å­˜å¤±è´¥ï¼Œä¿å­˜åˆ°å½“å‰ç›®å½•
        filename = f"device_inspection_report_{timestamp}.txt"
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(report)
        print(f"\næŠ¥å‘Šå·²ä¿å­˜åˆ°å½“å‰ç›®å½•: {filename}")
        print(f"é”™è¯¯ä¿¡æ¯: {e}")
    
    # å¦‚æœæœ‰å¼‚å¸¸è®¾å¤‡ï¼Œè¿”å›éé›¶é€€å‡ºç 
    abnormal_count = sum(1 for r in results.values() 
                        if r.get('status') in ['offline', 'warning', 'error'])
    
    if abnormal_count > 0:
        print(f"\nè­¦å‘Š: å‘ç° {abnormal_count} å°å¼‚å¸¸è®¾å¤‡")
        return 1
    
    print("\næ‰€æœ‰è®¾å¤‡æ£€æŸ¥æ­£å¸¸ï¼")
    return 0

if __name__ == "__main__":
    try:
        exit_code = main()
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\n\nå·¡æ£€è¢«ç”¨æˆ·ä¸­æ–­")
        sys.exit(130)
    except Exception as e:
        print(f"\nç¨‹åºè¿è¡Œå‡ºé”™: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)